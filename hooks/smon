#!/usr/bin/env python

import os
import subprocess
import json
import time
import sys

name="_smon.out"
delay=30

sid=os.getsid(os.getpid())

def get_size(start_path = '.'):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

with open(name, "w") as outfile:

    env = {}
    #put some batch scheduler specific env
    for k in os.environ:
        if k.startswith(("PBS_", "SLURM_", "OSG")):
            env[k] = os.environ[k]

    #figure out max PPN
    max_ppn = os.sysconf('SC_NPROCESSORS_CONF') #default to all available cores
    if "PBS_NUM_PPN" in os.environ:
        max_ppn = int(os.environ["PBS_NUM_PPN"])
    #from https://slurm.schedmd.com/srun.html
    if "SLURM_CPUS_ON_NODE" in os.environ:
        max_ppn = int(os.environ["SLURM_CPUS_ON_NODE"])

    #figure out max mem
    max_mem = os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_PHYS_PAGES')
    max_walltime = None
    if "PBS_JOBID" in os.environ:
        #PBS doesn't expose requested memory in ENV.. I need to query from qstat
        if sys.version_info >= (3,0):
            out=subprocess.check_output(["qstat", "-f1", os.environ["PBS_JOBID"]], encoding='utf8')
        else:
            out=subprocess.check_output(["qstat", "-f1", os.environ["PBS_JOBID"]])
        qstat={}
        for line in out.split("\n"):
            delpos = line.find("=")
            if delpos == -1: continue
            k=line[0:delpos].strip()
            v=line[delpos+1:].strip()
            qstat[k] = v

        if "Resource_List.vmem" in os.environ:
            #only carbonate has this
            max_mem_str = qstat["Resource_List.vmem"] #64gb, etc..
            if max_mem_str.endswith("gb"):
                #max_mem = int(max_mem_str[0:-2])*1024*1024*1024
                max_mem = int(max_mem_str[0:-2])*1000*1000*1000 #pbs treats gb and GB the same.. and I believe as "1000^3"

        if "Walltime.Remaining" in os.environ:
            max_walltime = int(qstat["Walltime.Remaining"])

    if "SLURM_MEM_PER_NODE" in os.environ:
        #Default units are megabytes unless the SchedulerParameters configuration parameter includes the "default_gbytes" option for gigabytes.
        #https://slurm.schedmd.com/sbatch.html
        max_mem = int(os.environ["SLURM_MEM_PER_NODE"])*1024*1024 

    if "PBS_WALLTIME" in os.environ:
        max_walltime = int(os.environ["PBS_WALLTIME"])
    
    #TODO - figure out how to find walltime for slurm
    #https://confluence.csiro.au/display/SC/Reference+Guide%3A+Migrating+from+Torque+to+SLURMt

    #dump info that doesn't change on the first entry
    json.dump({
        "time": time.time(), 
        "uname": os.uname(), #os/kernerl/hostname version
        #"cpu_count": psutil.cpu_count(), 
        "cpu_total": os.sysconf('SC_NPROCESSORS_CONF'),
        "cpu_requested": max_ppn,

        #"memory_total": psutil.virtual_memory().total,
        "memory_total": os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_PHYS_PAGES'),
        "memory_requested": max_mem,

        "walltime_requested": max_walltime,

        "sid": sid,
        "uid": os.environ['USER'],

        "env": env,

        }, outfile)
    outfile.write("\n")
    outfile.flush()

    #print("updating "+name+" every "+str(delay)+" seconds")
    while True:

        #query process under current session
        processes = []
        if sys.version_info >= (3,0):
            out=subprocess.check_output(["ps", "-s", str(sid), "ho", "pid,pcpu,pmem,rss,vsz,etime,cmd"], encoding='utf8')
        else:
            out=subprocess.check_output(["ps", "-s", str(sid), "ho", "pid,pcpu,pmem,rss,vsz,etime,cmd"])
        for line in out.split("\n"):
            if line == "":
                continue
            tokens=line.split()
            pid=tokens[0]
            pcpu=float(tokens[1])
            pmem=float(tokens[2])
            rss=int(tokens[3])
            vsz=int(tokens[4])
            etime=tokens[5]
            cmd=' '.join(tokens[6:])

            #ignore myself.
            if cmd.startswith("ps -s"):
                continue

            if etime != "00:00": #pcpu > 0 or pmem > 0:
                processes.append({"pid": pid, "pcpu": pcpu, "pmem": pmem, "rss": rss, "vsz": vsz, "etime": etime, "cmd": cmd})

        #debug..
        #print(json.dumps(processes, indent=4))
        #sys.stdout.flush()

        #query disk usage
        disks = []
        if sys.version_info >= (3,0):
            out=subprocess.check_output(["du", "-s"], encoding='utf8')
        else:
            out=subprocess.check_output(["du", "-s"])
        for line in out.split("\n"):
            if line == "":
                continue
            tokens=line.split()
            size=int(tokens[0])
            path=tokens[1]
            disks.append({"path": path, "size": size})

        #debug
        #print(json.dumps(disks, indent=4))
        #sys.stdout.flush()

        json.dump({
            "time": time.time(), 
            "processes": processes, 
            "disks": disks,
            "memory_avail": os.sysconf('SC_PAGE_SIZE') * os.sysconf('SC_AVPHYS_PAGES'),
            #"memory_avail": psutil.virtual_memory().available,
            #"memory_used": psutil.virtual_memory().used,
            #"memory_free": psutil.virtual_memory().free,
            }, outfile)
        outfile.write("\n")
        outfile.flush()

        time.sleep(delay)
